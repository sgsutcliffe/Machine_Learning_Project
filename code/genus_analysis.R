library(tidyverse)
library(broom)
library(ggtext)

#### Video 2 CC121 ####

#From the raw-data we will look at the shared file rows are the different samples and columns are the different OTUs
#Cells are the abundance
#Data is generated by mothur but not different then how viral contigs in my analysis can sometimes be classified as vOTUs even if multiple viral contigs can represent
#multiple viral species or strains. I digress.

#Note I named my 'raw data' folder differently

shared <- read_tsv("raw_data-0.3/baxter.subsample.shared", col_types = cols(Group = col_character(), .default = col_double())) %>%
  rename_all(tolower) %>%
  select(group, starts_with("otu")) %>% #Add a select to keep group column and remove label and numotus
  pivot_longer(-group, names_to="otu", values_to="count")

#This is the abundance per OTU per group

#Lesson learned: 
#R doesn't like wide dataframes it prefers long dataframes. That it explains things I have done in the past without knowing it.
#Telling read_tsv() the column data types in loading data speeds things up.

#This assigns taxonomy to OTU at the genus level
taxonomy <- read_tsv("raw_data-0.3/baxter.cons.taxonomy") %>%
  rename_all(tolower) %>%
  select(otu, taxonomy) %>% #don't need size
  mutate(otu = tolower(otu), #Mutate to change columns to lower otus to lowercas to match the 'shared' file.
         #Next thing clean taxonomy to get genus level names.
         taxonomy = str_replace_all(taxonomy, "\\(\\d+\\)", ""), #Here we use regex to remove the (100) which tells the percentage of the OTU had that classification
         #An issue with this taxonomy in this version of Mothur output is that everything unclassified is labeled unclassified
         #So despite being different Family-level taxa a genus would still get labled 'unclassified' so we want to change that
         taxonomy = str_replace(taxonomy, ";unclassified", "_unclassified"),
         taxonomy = str_replace_all(taxonomy, ";unclassified", ""),
         taxonomy = str_replace_all(taxonomy, ";$", ""),
         taxonomy = str_replace_all(taxonomy, ".*;", ""))

#Get the metadata
metadata <- read_tsv("raw_data-0.3/baxter.metadata.tsv", col_types=cols(sample = col_character())) %>%
  rename_all(tolower) %>% rename(group = sample) %>%
  #There is a medical condition he is interested in for this data but I don't really understand it. It's fine I think.
  #srn is screen relevant neuplasia or something like that
  #dx_bin has all the diagnosis
  mutate(srn = dx_bin == "Adv Adenoma" | dx_bin == "Cancer", lesion = dx_bin == "Adv Adenoma" | dx_bin == "Cancer" | dx_bin == "Adenoma")          
# OTU counts in themselves are useless, so make a composite table with both OTU and genus.
# Next step is to join the shared and taxonomy dataframes by OTU names thus giving taxonomy to my shared dataframe

composite <- inner_join(shared, taxonomy, by='otu') %>%
  group_by(group, taxonomy) %>%  #Now collapse the same taxonomy by the same sample, i.e. sometimes you can have multiple OTUs with the same genus
  summarize(count = sum(count), .groups="drop") %>%
  group_by(group) %>% mutate(rel_abund = count / sum(count)) %>% #Now that we have counts per group and per taxonomy we then get the relative abundance in new column
  ungroup() %>%
  select(-count) %>% #Removes counts 
  inner_join(., metadata, by="group") #Add in the metadat
  

#I will write this output to processed data
write.table(composite, file='processed_data/composite.tsv', sep='\t', row.names = FALSE)

##### Third Video CC122 ####

#Goal to find which genus might be associated with Screen Relevant Neoplasia (SRN)

#Wilcoxon signed-rank test: Non-parametric Statisitcal hypothesis test to compare the two populations using a set of matched samples
#Individuals with or without SRN, two groups

composite <- read_tsv("processed_data/composite.tsv")

sig_genera <- composite %>%
  nest(data = -taxonomy) %>% #Here we will exclude all data except taxonomy column (genera), and puts metadata into a data column which is a tibble [490 x 20], 490 rows or subjects in a study and 20 columns of metadata
  mutate(test = map(.x=data, ~wilcox.test(rel_abund~srn, data=.x) %>% tidy)) %>% #Mutate allows a new column containing the results of statistical tests, called 'test'. Map will run the function Wilcoxon test
  #The two variables being relative abundance of an OTU and whether or not they have SRN
  #.x ; is the argument name for the wilcox test not the data tibble dataframe
  # The results of the function is the <htest> but that result can be piped
  # tidy command comes from broom package
  # After  tidy command it turns htest into a tibble of 1 x 4
  # Then, after he'll unest to have the full dataframe back. I need to look at this more!
  unnest(test) %>%
  # Unbundled the htest, so you can see that shiny shiny p-value for every genera
  # Then we need to correct for multiple-comparison errors, as we have 300 genera, so about 14 could be false positives
  # There are 36 but some are false-positives
  mutate(p.adjust = p.adjust(p.value, method="BH")) %>%
  filter(p.adjust < 0.05) %>% 
  select(taxonomy, p.adjust)
write.table(sig_genera, file='processed_data/sig_genera.tsv', sep='\t', row.names = FALSE)
  
composite %>%
  inner_join(sig_genera, by="taxonomy") %>%
  mutate(rel_abund = 100 * (rel_abund + 1/20000), taxonomy = str_replace(taxonomy, "(.*)", "*\\1*"), taxonomy = str_replace(taxonomy, "\\*(.*)_unclassified\\*", "Unclassified<br>*\\1*"), srn =factor(srn,levels=c(T,F))) %>%
  ggplot(aes(x=rel_abund, y=taxonomy, color=srn, fill=srn)) +
  geom_jitter(position = position_jitterdodge(dodge.width = 0.8, 
                                              jitter.width = 0.3),
              shape=21) +
  #Ooo jitter plot, that's new for me to, and dodge points, with space
  stat_summary(fun.data =  median_hilow, fun.args = list(conf.int=0.5),
               geom="pointrange", position = position_dodge(width=0.8),
               color="black", show.legend=FALSE) +
               scale_x_log10() +
  scale_color_manual(NULL, 
                     breaks = c(F,T),
                     values = c("gray", "dodgerblue"),
                     labels = c("Healthy", "SRN")) +
  scale_fill_manual(NULL, 
                     breaks = c(F,T),
                     values = c("gray", "dodgerblue"),
                     labels = c("Healthy", "SRN")) +
  labs(x="Relative abundance (%)", y=NULL) +
  theme_classic() +
  theme(axis.text.y = element_markdown())
  #adds stats to the figure, the median value
  #Recall that scale_x_log10 works with stat_summary in this situation because I am using median values. If you were using mean values, you would use
  #coord_trans(x="log10")

ggsave("figures/significant_genera.jpeg", device ="jpeg", width=6, height=4)

##### Fourth video ####

#Goal here is to figure out which genera are significant for SCN

#Load in data from previous steps so you don't need to run it every time
composite <- read_tsv("processed_data/composite.tsv")
sig_genera <-read_tsv("processed_data/sig_genera.tsv")


#create function
get_sens_spec <- function(threshold, score, actual, direction){
  
  threshold <-  100
  score <- test$score
  actual <- test$srn
  direction <- "greaterthan"
  
  predicted <- if(direction == "greaterthan") {
    score > threshold
  } else {
    score < threshold
  }
  tp <- sum(predicted & actual)
  #tp; true positive
  tn <- sum(!predicted & !actual)
  #tn; true negatives
  fp <- sum(predicted & !actual)
  #fp; false positives
  fn <- sum(!predicted & actual)
  
  specificity <- tn / (tn + fp)
  sensitivity <- tp / (tp + fn)
  
  tibble("specificity" = specificity, "sensitivity" = sensitivity)
}
#threshold; 100 for fit result, score, actual fit result, actual, diagnosis or srn column, direction, whether higher  or lower values, 
  
test <- composite %>%
  inner_join(sig_genera, by="taxonomy") %>%
#We want SRN, group taxonomy, relatibe abundance, fit_result (which is a measurement of blood in stool), srn
  select(group, taxonomy, rel_abund, fit_result, srn) %>%
  pivot_wider(names_from=taxonomy, values_from=rel_abund) %>%
  pivot_longer(cols=-c(group, srn), names_to="metric", values_to="score") %>%
  filter(metric == "fit_result")
#Fit test is used to predict whether you need to get colonoscopy for SRN
#Lets make a ROC curve based on fit-score
